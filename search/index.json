[{"content":"命令\r详细内容请查看官方文档手册：\nCommands | Hugo官方文档 (opendocs.io)\n命令 简解 ⭐hugo hugo 用于构建您的网站 ⭐hugo convert 将您的内容转换为不同的格式 hugo convert toJSON 将前置内容转换为JSON格式 ⭐hugo deploy 将您的网站部署到云服务提供商 ⭐hugo env 打印Hugo版本和环境信息 hugo gen 一系列有用的生成器集合 hugo gen chromastyles 生成用于 Chroma 代码高亮的 CSS 样式表 hugo gen doc 生成Hugo CLI的Markdown文档 hugo gen man 生成Hugo CLI的man页 ⭐hugo import 从其他网站生成器导入你的网站 ⭐hugo import jekyll 从Jekyll导入到Hugo ⭐hugo list 列出各种类型的内容 ⭐hugo list all 列出所有文章 ⭐hugo list drafts 列出所有草稿 hugo list expired 列出已过期的所有文章 hugo list future 列出所有未来日期的文章 hugo mod Hugo模块的各种辅助工具 ⭐hugo mod clean 删除当前项目的Hugo模块缓存 ⭐hugo mod get 解决当前 Hugo 项目的依赖关系 ⭐hugo mod init 将此项目初始化为Hugo模块 hugo mod npm 各种npm助手 hugo mod npm pack 实验性功能：为您的项目准备并编写一个复合的 package.json 文件 hugo mod tidy 删除 go.mod 和 go.sum 中未使用的条目 hugo mod vendor 将所有模块依赖项打包到 _vendor 目录中 hugo mod verify 验证依赖项 ⭐hugo new 创建站点的新内容 ⭐hugo new content 为您的网站创建新内容 ⭐hugo new site 创建新站点（框架） ⭐hugo new theme 创建一个名为[name]的新主题（模板） ⭐hugo server 高性能的网页服务器 hugo server trust 将本地 CA 安装到系统的信任存储中 hugo convert toTOML 将前置信息转换为 TOML 格式 ⭐hugo version 打印Hugo版本和环境信息 hugo completion zsh 生成用于zsh shell的自动补全脚本 hugo completion powershell 为powershell生成自动补全脚本 ⭐hugo mod graph 打印模块依赖图 ⭐hugo config 打印站点配置 ⭐hugo config mounts 打印已配置的文件挂载 hugo completion 为指定的shell生成自动完成脚本 hugo completion fish 生成fish shell的自动补全脚本 hugo convert toyaml 将前置内容转换为YAML格式 ⭐hugo completion bash 生成bash shell的自动完成脚本 前置格式\r来源：前置格式 | Hugo官方文档 (opendocs.io)\nHugo允许您在内容文件中使用yaml、toml或json来添加前置格式。\n前置格式允许您将元数据附加到[内容类型]的实例中-即嵌入在内容文件中，并且是Hugo赋予其强大功能的众多特性之一。\n文章的开头里的前置格式编写将影响接下来整篇文章的环境配置\n前置格式格式\rHugo支持四种前置格式格式，每种格式都有其自己的标识标记。\nTOML\n标识符为开放和关闭的 +++。\nYAML\n标识符为开放和关闭的 ---。\nJSON\n由单个由{和}括起来的JSON对象组成，后跟一个新行。\nORG\nOrg模式关键字组，格式为 #+KEY: VALUE 。任何不以#+开头的行都会结束前置格式部分。 关键字值可以是字符串（#+KEY: VALUE）或以空格分隔的字符串列表（#+KEY[]: VALUE_1 VALUE_2）。\n示例\r1 2 3 4 5 6 7 8 9 10 11 12 categories: - Development - VIM date: \u0026#34;2012-04-06\u0026#34; description: spf13-vim是适用于Vim的跨平台vim插件和资源分发。 slug: spf13-vim-3-0-release-and-new-website tags: - .vimrc - plugins - spf13-vim - vim title: spf13-vim 3.0版本发布和新网站 前置格式变量\r预定义\rHugo有一些预定义的变量。请参阅页面变量了解如何在模板中调用这些预定义变量的方法。\naliases\n一个包含一个或多个别名（例如已重命名内容的旧发布路径）的数组，这些别名将在输出目录结构中创建。有关详细信息，请参阅别名。\naudio\n与页面相关的音频文件路径数组；opengraph 内部模板使用它来填充 og:audio。\ncascade\n一组前置格式键的映射，其值会传递给页面的子页，除非被自身或更近的祖先级别的cascade覆盖。有关详细信息，请参阅前置格式级联 。\ndate\n分配给此页面的日期时间。通常从前置格式的date字段获取此值，但此行为是可配置的。\ndescription\n内容的描述。\ndraft\n如果为true，则只有在向hugo命令传递了--buildDrafts标志时，内容才会被呈现。\nexpiryDate\n内容不再由Hugo发布的日期时间；过期内容只有在向hugo命令传递了--buildExpired标志时才会呈现。\nheadless\n如果为true，则将叶子包设置为无头。\nimages\n与页面相关的图像文件路径数组；用于内部模板，如_internal/twitter_cards.html。\nisCJKLanguage\n如果为true，Hugo将明确将内容视为CJK语言；在CJK语言中.Summary和.WordCount都能正确工作。\nkeywords\n内容的元关键字。\nlayout\n当渲染内容时，Hugo应从查找顺序中选择的布局。如果在前置格式中未指定type，Hugo将在与内容部分对应的布局目录中查找相同名称的布局。请参阅内容类型。\nlastmod\n内容最后修改的日期时间。\nlinkTitle\n用于创建到内容的链接；如果设置了，Hugo默认使用title前的linkTitle。\nmarkup\n实验性; 指定 \u0026quot;rst\u0026quot; 以获取reStructuredText（需要 rst2html）或 \u0026quot;md\u0026quot;（默认）以获取Markdown。\noutputs\n允许您指定特定于内容的输出格式。请参阅输出格式。\npublishDate\n如果发布日期在未来，只有在向hugo命令传递了--buildFuture标志时才会呈现内容。\nresources\n用于配置页面包资源。请参阅页面资源。\nseries\n此页面所属系列的数组，作为series 分类法的子集；被opengraph内部模板用于填充 og:see_also。\nslug\n覆盖URL路径的最后一段。不适用于部分页面。有关详细信息，请参阅URL管理。\nsummary\n在.Summary页面变量中提供文章摘要时使用的文本；有关详细信息，请参阅内容摘要部分。\ntitle\n内容的标题。\ntype\n内容的类型；如果未在前置格式中指定，此值将自动从目录（即[部分]）中派生。\nurl\n覆盖整个URL路径。适用于常规页面和部分页面。有关详细信息，请参阅URL管理。\nvideos\n与页面相关的视频文件路径数组；opengraph 内部模板使用它来填充 og:video。\nweight\n用于对内容排序。较低的权重会更优先显示。如果设置了权重，则权重应为非零，因为0会被解释为未设置的权重。\n索引的复数形式的字段名称。请参阅上述前置格式示例中的tags和categories。请注意，用户定义的分类法的复数形式不能与任何预定义的前置格式变量相同。\n如果既不存在slug也不存在url，且在站点配置文件中未以其他方式配置永久链接，Hugo将使用内容文件的文件名创建输出URL。有关Hugo路径的说明，请参阅内容组织 ，有关自定义Hugo默认行为的方法，请参阅URL管理。\n用户定义的\r您可以将字段任意添加到前置格式中，以满足您的需求。这些用户定义的键值对被放置在单个.Params变量中，用于在模板中使用。\ninclude_toc 和 show_comments 可以通过 .Params.include_toc 和 .Params.show_comments 使用。有关在模板中使用Hugo的页面级和站点级变量的更多信息，请参阅[变量]章节。\n示例\r1 2 include_toc: true show_comments: false 前置格式级联\r只要在保留的cascade前置格式键下方定义，任何节点或部分都可以将一组前置格式值传递给其子代。\n针对特定页面\rcascade块可以是一个带有可选_target关键字的片段，允许多个cascade值针对不同的页面集进行定位。\n1 2 3 4 5 6 7 8 9 10 cascade: - _target: kind: page lang: en path: /blog/** background: yosemite.jpg - _target: kind: section background: goldenbridge.jpg title: Blog 可用于 _target 的关键字：\npath\nGlob模式，用于匹配/content下方的内容路径。期望的是类Unix的斜杠。匹配支持双星号，因此可以匹配像/blog/*/**这样的模式，以匹配三级及以下的内容。\nkind\n匹配页面的类型的Glob模式，例如{home,section}。\nlang\n匹配页面的语言的Glob模式，例如{en,sv}。\nenvironment\n匹配构建环境的Glob模式，例如{production,development}。\n上述的任何一个都可以省略。\n示例\r在content/blog/_index.md中\n1 2 3 cascade: banner: images/typewriter.jpg title: Blog 有了上面的示例，当调用.Params.banner时，Blog部分页面及其子页面将返回images/typewriter.jpg，除非：\n该子页面设置了自己的banner值 或更近的祖先节点设置了自己的cascade.banner值。 ","date":"2024-09-26T22:42:13+08:00","permalink":"https://Mr-qingjiegong.github.io/p/hugo%E8%AF%AD%E6%B3%95/","title":"Hugo语法"},{"content":"title: \u0026ldquo;标题内容\u0026rdquo;\ndate: 文章创造时间\nimage: 封面图片\ncategories：文章分类\ntags：文章添加标签\ndraft: true 表示为草稿文件，正式发布前需将值修改为 false，或者直接删除 draft 整个参数，否则正式发布时不会生成文章。\n简介\r为啥采用hugo，不采用hexo框架？\n问题很好，没办法解释，两个框架都使用过，个人感觉hexo在主题上更丰富些，hugo在维护上更方便点，所以还是用回了hugo\n文章搬运再修饰了脚本控制部分 ： https://letere-gzj.github.io/hugo-stack/ （啥？喷我搬运！人家已经写得非常好了，艺术品欣赏就好何必自己欺骗自己说是自己的呢🤡）\n环境准备\r安装git\r前往【Git官网】，下载安装程序 一直点下一步，默认安装即可 安装hugo\r官网：The world’s fastest framework for building websites | Hugo (gohugo.io)\n前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip 搭建博客\r创建博客\r（1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行 （2）敲打命令hugo new site xxxx创建hugo文件 （3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中 目录结构：\n1 2 3 4 5 6 7 8 . ├── archetypes # 存放文章模板 ├── config.toml # 简单的配置文件 ├── content # 存放文章 ├── data # 存放生成静态页面时的配置文件 ├── layouts # 存放页面布局的模板 ├── static # 存放图片等静态内容 └── themes # 存放下载的主题 （4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 配置主题\r（1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载 （2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content （4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 （5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章 Github部署\r常规部署\r（1）前往【Github官网】，创建仓库 {github用户名}.github.io （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 Github Action自动部署\r（1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic) （3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 脚本控制部署\r做GitHub action自动化流程控制任务时，发现上传文件的时候并不符合，既然依旧需要git push进行上传，何不用脚本来进行编写控制能，还省去一堆麻烦\nshell脚本\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //删除public文件夹 rf -rf D:\\hugo\\qingjiegong\\public //hugo生成站点文件 hugo -D //GitHub上传更新 cd public git init git add . git commit -m \u0026#34;update\u0026#34; //git branch -M master //master还是main分支看自己部署时的存放路径 //git remote add origin https://你的GitHub仓库名.git //git push -u origin master git push bat脚本\rWindows系统采用bat脚本，文件后缀名为.bat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //删除public文件夹 rd /s /q D:\\hugo\\qingjiegong\\public //hugo生成站点文件 hugo -D //GitHub上传更新 cd public git init git add . git commit -m \u0026#34;update\u0026#34; //git branch -M master //master还是main分支看自己部署时的存放路径 //git remote add origin https://你的GitHub仓库名.git //git push -u origin master git push 音乐播放器设置\r引入音乐播放器\r【Aplayer官方文档】 名称 默认值 描述 container document.querySelector(’.aplayer') 播放器容器元素 fixed false 开启吸底模式, 详情 mini false 开启迷你模式, 详情 autoplay false 音频自动播放 theme ‘#b7daff’ 主题色 loop ‘all’ 音频循环播放, 可选值: ‘all’, ‘one’, ’none’ order ’list’ 音频循环顺序, 可选值: ’list’, ‘random’ preload ‘auto’ 预加载，可选值: ’none’, ‘metadata’, ‘auto’ volume 0.7 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 audio - 音频信息, 应该是一个对象或对象数组 audio.name - 音频名称 audio.artist - 音频艺术家 audio.url - 音频链接 audio.cover - 音频封面 audio.lrc - 详情 audio.theme - 切换到此音频时的主题色，比上面的 theme 优先级高 audio.type ‘auto’ 可选值: ‘auto’, ‘hls’, ’normal’ 或其他自定义类型, 详情 customAudioType - 自定义类型，详情 mutex true 互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 lrcType 0 详情 listFolded false 列表默认折叠 listMaxHeight - 列表最大高度 storageName ‘aplayer-setting’ 存储播放器设置的 localStorage key （1）在博客主目录中创建文件layouts\\partials\\footer\\custom.html，此文件为Stack主题作者留给我们加入自定义组件用的文件(可以查看主题源码同路径文件找到) （2）查看官方文档，引入对应的脚本，css到custom.html中，页面最下面就会出现音乐播放器 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; （3）修改 ap对象 配置，改成吸底模式 1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); （4）填写 audio 数组，引入歌曲，封面和歌词 lrcType 的值具体看【文档】 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const staticDir = {{ .Site.Home.Permalink }} const ap = new APlayer({ ..., lrcType: 3, audio: [ { name: \u0026#39;name\u0026#39;, // 歌名 artist: \u0026#39;artist\u0026#39;, // 歌手 url: \u0026#39;url.mp3\u0026#39;, // 歌曲路径 cover: \u0026#39;cover.jpg\u0026#39;, // 封面路径 lrc: \u0026#39;lrc.lrc\u0026#39;, // 歌词路径 }, { // 本地路径引入写法（有子目录就在staticDir后面继续拼接） name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: staticDir + \u0026#39;url.mp3\u0026#39;, cover: staticDir + \u0026#39;cover.jpg\u0026#39;, lrc: staticDir + \u0026#39;lrc.lrc\u0026#39;, } ] }); 到这一步音乐播放器已经引入完了\n音乐播放器样式切换\r（1）通过阅读Stack主题的源码可以看到，主题样式的切换是通过[data-scheme=\u0026quot;light/darck\u0026quot;] {...} （2）所以我们可以准备两种Aplayer的css，用[data-scheme=\u0026quot;light\u0026quot;]{ 亮的css样式 }包裹亮的，用[data-scheme=\u0026quot;dark\u0026quot;]{ 暗的css样式 }包裹暗的，这里直接给各位准备好了 aplayer-light.scss（Ctrl+S保存） aplayer-dark.scss（Ctrl+S保存） （3）在博客主目录中创建文件assets\\scss\\custom.scss，此文件为Stack主题作者留给我们加入自定义样式用的文件(可以查看主题源码同路径文件找到) （4）将上述两个scss文件放到跟 custom.scss同目录下，并通过@import来进行引入文件 1 2 3 4 5 /** * 【custom.scss】 */ @import \u0026#34;aplayer-light.scss\u0026#34;; @import \u0026#34;aplayer-dark.scss\u0026#34;; （5）因为音乐播放器的css改为我们本地文件引入了，所以 custom.html 中的link标签可以将它注释掉或者删掉了 1 2 3 \u0026lt;!-- custom.html --\u0026gt; ... \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; --\u0026gt; 到这一步样式随主题切换已经完成了\n音乐播放进度保留\r（1）实现思路：页面切换前，把歌曲的 歌曲序号，播放时长，播放状态 记录下来；在页面切换加载完之后，我们调用Aplayer的接口切换歌曲，调整时长，并选择播放or暂停 （2）通过console.log(ap)打印ap对象，或者官方文档，可以找到我们需要的参数 list.index：歌曲序号 audio.currentTime：播放时长 paused ：播放状态（是否暂停） （3）通过【官方文档】可以查找到我们需要调用的接口 ap.list.switch(index: number)：切换歌曲 ap.seek(time: number)：调整时长 ap.play()：播放歌曲 （4）需要的东西已经找齐，只需在 custom.html 加入以下代码即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... /** * 页面销毁前监听 */ window.onbeforeunload = () =\u0026gt; { // 将播放信息用对象封装，并存入到localStorage中 const playInfo = { index: ap.list.index, currentTime: ap.audio.currentTime, paused: ap.paused }; localStorage.setItem(\u0026#34;playInfo\u0026#34;, JSON.stringify(playInfo)); }; /** * 页面加载后监听 */ window.onload = () =\u0026gt; { // 从localStorage取出播放信息 const playInfo = JSON.parse(localStorage.getItem(\u0026#34;playInfo\u0026#34;)); if (!playInfo) { return; } // 切换歌曲 ap.list.switch(playInfo.index); // 等待500ms再执行下一步(切换歌曲需要点时间，不能立马调歌曲进度条) setTimeout(() =\u0026gt; { // 调整时长 ap.seek(playInfo.currentTime); // 是否播放 if (!playInfo.paused) { ap.play() } }, 500); }; \u0026lt;/script\u0026gt; 引入PJAX\r基本引入\r（1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的 【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将着元素定为要刷新的对象 （4）根据官方文档，在 custom.html 加入以下代码来引入PJAX 1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n文章样式修复\r（1）随便点进其中一篇文章，可以发现文章内容的样式丢失，缺少文章该有的边框 （2）通过手动刷新，对比页面元素发现，决定文章样式的是\u0026lt;body\u0026gt; 标签中的class名: article-page，存在此class名就会识别到文章该有的css （3）因为\u0026lt;body\u0026gt;内包含整个页面的所有内容，包括我们的音乐播放器，所以不能让PJAX监听\u0026lt;body\u0026gt;标签 阅读官方文档发现，官方提供了数据预处理方法，让我们处理数据 我们通过预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) // 放行pjax处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 这样我们切页面后，都会自动把body中的className更新，就不会丢失样式了\n主题切换修复\r（1）当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 （2）阅读Stack主题源码\\assets\\ts\\colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但没有该元素重新绑定点击事件，导致点击主题切换失效 （3）解决思路：在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。 阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 这样元素的点击事件重新绑定，主题颜色就能正常切换了\n文章搜索修复\r（1）使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 （2）查看layouts\\ts\\search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 （3）解决思路类似上面的，把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来，由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 - （以下操作请复制同路径同名文件到自己主目录下修改，不要在主题源码中修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 【search.tsx】 * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } （4）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 这样search.tsx能正常初始化，文章搜索功能恢复\n搜索内容跳转修复\r（1）虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了 （2）阅读 search.tsx 源码可知，搜索内容的数据，是通过React.render，动态渲染回页面的，这些没有触发PJAX，所以PJAX没有识别到。阅读PJAX文档，官方提供给了我们重新解析数的方法，所以在React.render之后，我调用PJAX方法，重新解析页面即可 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【search.tsx】 */ private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 这样动态渲染出的页面数据就能被PJAX识别到，就不会刷新页面跳转了\n文章评论修复\r（1）如果博客有开启评论功能的话，会发现评论的脚本不生效了 （2）由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理： 用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- custom.html --\u0026gt; ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 这样PJAX会自动加载我们的评论脚本\n引入进度条\r（1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度 （2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2024-09-20T12:06:24+08:00","permalink":"https://Mr-qingjiegong.github.io/p/hugo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","title":"Hugo部署静态博客"}]